package java.Algorithm.leetcode.dp;

/**
 * 解码问题
 * 和之前刷的零钱兑换很像，底层是个01背包问题：物品有两种规格，要么一个数字，要么满足要求的两个数字。运用标准的动态规划即可：
 *
 * 建立动态规划数组dp，dp[i]用于记录字符串至第i-1位前的解码方法的总数。依次扫描数字，当前数字不为0时，dp[i]+=dp[i-1]表示当前组合数量包括前一位数字前的组合总数；当前数字与前一位组合的数字处于10-26时，dp[i]+=dp[i-2]表示当前组合数量包括前两位数字前的组合总数。最后只需要返回dp[s.length()]即可。
 *
 * 有个tip是当两位数算得0时，说明字符串出现连续两个0，此时可以直接返回0.因为"00"所在的字符串不存在解码方式。
 */
public class Main91 {
    //动态规划
    public int numDecodings(String s) {

        //dp[i]用于记录字符串至第i-1位前的解码方法的总数
        int[] dp = new int[s.length() + 1];
        dp[0] = 1;

        for(int i = 1; i < s.length() + 1; i++){
            //当前数字不为0时，dp[i] += dp[i - 1]表示当前组合数量包括前一位数字前的组合总数
            char c = s.charAt(i - 1);
            if(c != '0'){
                dp[i] += dp[i - 1];
            }
            //当前数字与前一位组合的数字处于10-26时，dp[i] += dp[i - 2]表示当前组合数量包括前两位数字前的组合总数
            if(i > 1){
                int num = (s.charAt(i - 2) - '0') * 10 + (c - '0');
                //提前剪枝：连续两个0没有对应解码方式
                if(num == 0){
                    return 0;
                }
                if(num > 9 && num < 27){
                    dp[i] += dp[i - 2];
                }
            }
        }

        return s.length() == 0 ? 0 : dp[s.length()];
    }

}
