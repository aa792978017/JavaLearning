1.为什么用位运算不用取模来计算index，而是对"hash%length-1"？为什么长度是2的幂次？
  (1)位运算性能比取模高，"hash%length-1"效果等同于取模
  (2)长度是2的幂次是因为：使用位运算计算index的时候，
  index结果等同于hashCode最后几位的值，所以只要输入的hashCode是均匀的，Hash算法就是均匀的
  (3)长度为2的幂次，后续resized时候，重新确认index将会非常简单，根据高一位是0或1，新index为旧index或旧index+旧长度

2.为什么是头插法？
  因为作者认为，后插入的进行搜索的概率比较大

3.多线程情况下，为什么jdk1.7的HashMap可能成环？
 （1）因为jdk1.7中的tranfer方法的设计问题，
 在这个方法扩容的时候，多线程下修改引用的时候会出现成环现象；
 （2）JDK1.8中去除了这个方法，改为了resize方法，防止了成环；
 但仍是非线程安全的，resize的时候进行put操作，很容易丢失刚插入的元素

4.在Java8当中，HashMap的结构有什么样的优化？
1.链表过长后，会转化为红黑树的结构，保证大量元素的时候，查询速度不会下降得很快。
红黑树的查询速度很快（查询，插入，删除时间复杂度为log(n)）
红黑树算法分析：http://www.360doc.com/content/16/0518/14/7510008_560156026.shtml



